<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Will&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Will&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Will Wan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Will's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Will's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Where there is a will, there is a way</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2025/05/06/Vue3%E7%BB%84%E4%BB%B6v-model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Will Wan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Will's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/05/06/Vue3%E7%BB%84%E4%BB%B6v-model/" class="post-title-link" itemprop="url">Vue3组件v-model</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-05-06 17:22:54 / 修改时间：17:59:03" itemprop="dateCreated datePublished" datetime="2025-05-06T17:22:54+08:00">2025-05-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>v-model 可以在组件上使用以实现双向绑定。从 Vue 3.4 开始，推荐的实现方式是使用 defineModel() 宏：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Child.vue --&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">const model &#x3D; defineModel()</span><br><span class="line"></span><br><span class="line">function update() &#123;</span><br><span class="line">  model.value++</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;Parent bound v-model is: &#123;&#123; model &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;button @click&#x3D;&quot;update&quot;&gt;Increment&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>父组件可以用 v-model 绑定一个值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Parent.vue --&gt;</span><br><span class="line">&lt;Child v-model&#x3D;&quot;countModel&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>defineModel() 返回的值是一个 ref。它可以像其他 ref 一样被访问以及修改，不过它能起到在父组件和当前变量之间的双向绑定的作用：</p>
<ul>
<li>它的 .value 和父组件的 v-model 的值同步；</li>
<li>当它被子组件变更了，会触发父组件绑定的值一起更新。</li>
</ul>
<p><strong>这意味着也可以用 v-model 把这个 ref 绑定到一个原生 input 元素上，在提供相同的 v-model 用法的同时轻松包装原生 input 元素：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const model &#x3D; defineModel()</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input v-model&#x3D;&quot;model&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<h2 id="v-model-的底层机制"><a href="#v-model-的底层机制" class="headerlink" title="v-model 的底层机制"></a>v-model 的底层机制</h2><p>defineModel 是一个便利宏。编译器将其展开为以下内容：</p>
<ul>
<li>一个名为 modelValue 的 prop，本地 ref 的值与其同步；</li>
<li>一个名为 update:modelValue 的事件，当本地 ref 的值发生变更时触发。</li>
</ul>
<p>在 3.4 版本之前，一般会按照如下的方式来实现上述相同的子组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Child.vue --&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">const props &#x3D; defineProps([&#39;modelValue&#39;])</span><br><span class="line">const emit &#x3D; defineEmits([&#39;update:modelValue&#39;])</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input</span><br><span class="line">    :value&#x3D;&quot;props.modelValue&quot;</span><br><span class="line">    @input&#x3D;&quot;emit(&#39;update:modelValue&#39;, $event.target.value)&quot;</span><br><span class="line">  &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>然后，父组件中的 v-model=”foo” 将被编译为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Parent.vue --&gt;</span><br><span class="line">&lt;Child</span><br><span class="line">  :modelValue&#x3D;&quot;foo&quot;</span><br><span class="line">  @update:modelValue&#x3D;&quot;$event &#x3D;&gt; (foo &#x3D; $event)&quot;</span><br><span class="line">&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>因为 defineModel 是声明了一个 prop，所以可以通过给 defineModel 传递选项，来声明底层 prop 的选项：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使 v-model 必填</span></span><br><span class="line"><span class="keyword">const</span> model = defineModel(&#123; <span class="attr">required</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供一个默认值</span></span><br><span class="line"><span class="keyword">const</span> model = defineModel(&#123; <span class="attr">default</span>: <span class="number">0</span> &#125;)</span><br></pre></td></tr></table></figure>

<p><strong>注意：如果为 defineModel prop 设置了一个 default 值且父组件没有为该 prop 提供任何值，会导致父组件与子组件之间不同步。</strong></p>
<p>例如：在下面的示例中，父组件的 myRef 是 undefined，而子组件的 model 是 1：</p>
<p>子组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> model = defineModel(&#123; <span class="attr">default</span>: <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure>

<p>父组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myRef = ref()</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Child v-model&#x3D;&quot;myRef&quot;&gt;&lt;&#x2F;Child&gt;</span><br></pre></td></tr></table></figure>

<h2 id="v-model-的参数"><a href="#v-model-的参数" class="headerlink" title="v-model 的参数"></a>v-model 的参数</h2><p>组件上的 v-model 也可以接受一个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent v-model:title&#x3D;&quot;bookTitle&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>在子组件中，我们可以通过将字符串作为第一个参数传递给 defineModel() 来支持相应的参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- MyComponent.vue --&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">const title &#x3D; defineModel(&#39;title&#39;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;title&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>如果需要额外的 prop 选项，应该在 model 名称之后传递：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> title = defineModel(<span class="string">'title'</span>, &#123; <span class="attr">required</span>: <span class="literal">true</span> &#125;)</span><br></pre></td></tr></table></figure>

<p><strong>v-model 的参数 3.4 之前的用法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- MyComponent.vue --&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">defineProps(&#123;</span><br><span class="line">  title: &#123;</span><br><span class="line">    required: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">defineEmits([&#39;update:title&#39;])</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input</span><br><span class="line">    type&#x3D;&quot;text&quot;</span><br><span class="line">    :value&#x3D;&quot;title&quot;</span><br><span class="line">    @input&#x3D;&quot;$emit(&#39;update:title&#39;, $event.target.value)&quot;</span><br><span class="line">  &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<h2 id="多个-v-model-绑定"><a href="#多个-v-model-绑定" class="headerlink" title="多个 v-model 绑定"></a>多个 v-model 绑定</h2><p>利用在 v-model 的参数小节中学到的指定参数与事件名的技巧，可以在单个组件实例上创建多个 v-model 双向绑定。组件上的每一个 v-model 都会同步不同的 prop，而无需额外的选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;UserName</span><br><span class="line">  v-model:first-name&#x3D;&quot;first&quot;</span><br><span class="line">  v-model:last-name&#x3D;&quot;last&quot;</span><br><span class="line">&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const firstName &#x3D; defineModel(&#39;firstName&#39;)</span><br><span class="line">const lastName &#x3D; defineModel(&#39;lastName&#39;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;firstName&quot; &#x2F;&gt;</span><br><span class="line">  &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;lastName&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>多个 v-model 3.4 之前的用法参看上面 v-model 的参数 3.4 之前的用法。</p>
<h2 id="处理-v-model-修饰符"><a href="#处理-v-model-修饰符" class="headerlink" title="处理 v-model 修饰符"></a>处理 v-model 修饰符</h2><p>学习输入绑定时，我们知道了 v-model 有一些内置的修饰符，例如 .trim，.number 和 .lazy。在某些场景下，你可能想要一个自定义组件的 v-model 支持自定义的修饰符。</p>
<p>我们看一下如何创建一个自定义的修饰符 capitalize，它会自动将 v-model 绑定输入的字符串值第一个字母转为大写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent v-model.capitalize&#x3D;&quot;myText&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>通过像这样解构 defineModel() 的返回值，可以在子组件中访问添加到组件 v-model 的修饰符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const [model, modifiers] &#x3D; defineModel()</span><br><span class="line"></span><br><span class="line">console.log(modifiers) &#x2F;&#x2F; &#123; capitalize: true &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;model&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>为了能够基于修饰符选择性地调节值的读取和写入方式，我们可以给 defineModel() 传入 get 和 set 这两个选项。这两个选项在从模型引用中读取或设置值时会接收到当前的值，并且它们都应该返回一个经过处理的新值。下面是一个例子，展示了如何利用 set 选项来应用 capitalize (首字母大写) 修饰符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const [model, modifiers] &#x3D; defineModel(&#123;</span><br><span class="line">  set(value) &#123;</span><br><span class="line">    if (modifiers.capitalize) &#123;</span><br><span class="line">      return value.charAt(0).toUpperCase() + value.slice(1)</span><br><span class="line">    &#125;</span><br><span class="line">    return value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;model&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p><strong>处理 v-model 修饰符 3.4 之前的用法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const props &#x3D; defineProps(&#123;</span><br><span class="line">  modelValue: String,</span><br><span class="line">  modelModifiers: &#123; default: () &#x3D;&gt; (&#123;&#125;) &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const emit &#x3D; defineEmits([&#39;update:modelValue&#39;])</span><br><span class="line"></span><br><span class="line">function emitValue(e) &#123;</span><br><span class="line">  let value &#x3D; e.target.value</span><br><span class="line">  if (props.modelModifiers.capitalize) &#123;</span><br><span class="line">    value &#x3D; value.charAt(0).toUpperCase() + value.slice(1)</span><br><span class="line">  &#125;</span><br><span class="line">  emit(&#39;update:modelValue&#39;, value)</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input type&#x3D;&quot;text&quot; :value&#x3D;&quot;props.modelValue&quot; @input&#x3D;&quot;emitValue&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<h2 id="带参数的-v-model-修饰符"><a href="#带参数的-v-model-修饰符" class="headerlink" title="带参数的 v-model 修饰符"></a>带参数的 v-model 修饰符</h2><p>下面是另一个例子，展示了如何在使用多个不同参数的 v-model 时使用修饰符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;UserName</span><br><span class="line">  v-model:first-name.capitalize&#x3D;&quot;first&quot;</span><br><span class="line">  v-model:last-name.uppercase&#x3D;&quot;last&quot;</span><br><span class="line">&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const [firstName, firstNameModifiers] &#x3D; defineModel(&#39;firstName&#39;)</span><br><span class="line">const [lastName, lastNameModifiers] &#x3D; defineModel(&#39;lastName&#39;)</span><br><span class="line"></span><br><span class="line">console.log(firstNameModifiers) &#x2F;&#x2F; &#123; capitalize: true &#125;</span><br><span class="line">console.log(lastNameModifiers) &#x2F;&#x2F; &#123; uppercase: true &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>带参数的 v-model 修饰符 3.4 之前的用法参考 v-model 修饰符 3.4 之前的用法。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2025/05/06/Vue3%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Will Wan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Will's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/05/06/Vue3%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6/" class="post-title-link" itemprop="url">Vue3组件事件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-05-06 16:54:11 / 修改时间：17:09:09" itemprop="dateCreated datePublished" datetime="2025-05-06T16:54:11+08:00">2025-05-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="触发与监听事件"><a href="#触发与监听事件" class="headerlink" title="触发与监听事件"></a>触发与监听事件</h2><p>在组件的模板表达式中，可以直接使用 $emit 方法触发自定义事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- MyComponent --&gt;</span><br><span class="line">&lt;button @click&#x3D;&quot;$emit(&#39;someEvent&#39;)&quot;&gt;Click Me&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>

<p>父组件可以通过 v-on (缩写为 @) 来监听事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent @some-event&#x3D;&quot;callback&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>


<p>组件的事件监听器也支持 .once 修饰符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent @some-event.once&#x3D;&quot;callback&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>注意：和原生 DOM 事件不一样，组件触发的事件没有冒泡机制。你只能监听直接子组件触发的事件。平级组件或是跨越多层嵌套的组件间通信，应使用一个外部的事件总线，或是使用一个全局状态管理方案。</strong></p>
<h2 id="事件参数"><a href="#事件参数" class="headerlink" title="事件参数"></a>事件参数</h2><p>如果需要在触发事件时附带一个特定的值，可以给 $emit 提供一个额外的参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click&#x3D;&quot;$emit(&#39;increaseBy&#39;, 1)&quot;&gt;</span><br><span class="line">  Increase by 1</span><br><span class="line">&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>

<p>然后在父组件中监听事件，我们可以先简单写一个内联的箭头函数作为监听器，此函数会接收到事件附带的参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyButton @increase-by&#x3D;&quot;(n) &#x3D;&gt; count +&#x3D; n&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>也可以用一个组件方法来作为事件处理函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyButton @increase-by&#x3D;&quot;increaseCount&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>该方法也会接收到事件所传递的参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increaseCount</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  count.value += n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有传入 $emit() 的额外参数都会被直接传向监听器。举例来说，$emit(‘foo’, 1, 2, 3) 触发后，监听器函数将会收到这三个参数值。</p>
<h2 id="声明触发的事件"><a href="#声明触发的事件" class="headerlink" title="声明触发的事件"></a>声明触发的事件</h2><p>组件可以显式地通过 defineEmits() 宏来声明要触发的事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">defineEmits([&#39;inFocus&#39;, &#39;submit&#39;])</span><br><span class="line"></span><br><span class="line">function buttonClick() &#123;</span><br><span class="line">  emit(&#39;submit&#39;)</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>** defineEmits() 宏不能在子函数中使用。如上所示，它必须直接放置在 <code>&lt;script setup&gt;</code> 的顶级作用域下**。</p>
<p>如果显式地使用了 setup 函数而不是 <code>&lt;script setup&gt;</code>，则事件需要通过 emits 选项来定义，emit 函数也被暴露在 setup() 的上下文对象上：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  emits: [<span class="string">'inFocus'</span>, <span class="string">'submit'</span>],</span><br><span class="line">  setup(props, ctx) &#123;</span><br><span class="line">    ctx.emit(<span class="string">'submit'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 setup() 上下文对象中的其他属性一样，emit 可以安全地被解构：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  emits: [<span class="string">'inFocus'</span>, <span class="string">'submit'</span>],</span><br><span class="line">  setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">    emit(<span class="string">'submit'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>emits 选项和 defineEmits() 宏还支持对象语法</strong>。通过 TypeScript 为参数指定类型，它允许我们对触发事件的参数进行验证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">const emit &#x3D; defineEmits(&#123;</span><br><span class="line">  submit(payload: &#123; email: string, password: string &#125;) &#123;</span><br><span class="line">    &#x2F;&#x2F; 通过返回值为 &#96;true&#96; 还是为 &#96;false&#96; 来判断</span><br><span class="line">    &#x2F;&#x2F; 验证是否通过</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>如果搭配 TypeScript 使用 <code>&lt;script setup&gt;</code>，也可以使用纯类型标注来声明触发的事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">const emit &#x3D; defineEmits&lt;&#123;</span><br><span class="line">  (e: &#39;change&#39;, id: number): void</span><br><span class="line">  (e: &#39;update&#39;, value: string): void</span><br><span class="line">&#125;&gt;()</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>尽管事件声明是可选的，还是推荐完整地声明所有要触发的事件，以此在代码中作为文档记录组件的用法</strong>。同时，事件声明能让 Vue 更好地将事件和透传 attribute 作出区分，从而避免一些由第三方代码触发的自定义 DOM 事件所导致的边界情况。</p>
<p><strong>注意：如果一个原生事件的名字 (例如 click) 被定义在 emits 选项中，则监听器只会监听组件触发的 click 事件而不会再响应原生的 click 事件。</strong></p>
<h2 id="事件校验"><a href="#事件校验" class="headerlink" title="事件校验"></a>事件校验</h2><p>和对 props 添加类型校验的方式类似，所有触发的事件也可以使用对象形式来描述。</p>
<p>要为事件添加校验，那么事件可以被赋值为一个函数，接受的参数就是抛出事件时传入 emit 的内容，返回一个布尔值来表明事件是否合法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const emit &#x3D; defineEmits(&#123;</span><br><span class="line">  &#x2F;&#x2F; 没有校验</span><br><span class="line">  click: null,</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 校验 submit 事件</span><br><span class="line">  submit: (&#123; email, password &#125;) &#x3D;&gt; &#123;</span><br><span class="line">    if (email &amp;&amp; password) &#123;</span><br><span class="line">      return true</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      console.warn(&#39;Invalid submit event payload!&#39;)</span><br><span class="line">      return false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function submitForm(email, password) &#123;</span><br><span class="line">  emit(&#39;submit&#39;, &#123; email, password &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2025/04/28/Vue3%E7%BB%84%E4%BB%B6props/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Will Wan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Will's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/28/Vue3%E7%BB%84%E4%BB%B6props/" class="post-title-link" itemprop="url">Vue3组件props</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-04-28 16:18:02 / 修改时间：17:10:19" itemprop="dateCreated datePublished" datetime="2025-04-28T16:18:02+08:00">2025-04-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Props-声明"><a href="#Props-声明" class="headerlink" title="Props 声明"></a>Props 声明</h2><p>一个组件需要显式声明它所接受的 props，这样 Vue 才能知道外部传入的哪些是 props，哪些是透传 attribute 。</p>
<p>在使用 <code>&lt;script setup&gt;</code> 的单文件组件中，props 可以使用 defineProps() 宏来声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const props &#x3D; defineProps([&#39;foo&#39;])</span><br><span class="line"></span><br><span class="line">console.log(props.foo)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>在没有使用 <code>&lt;script setup&gt;</code> 的组件中，props 可以使用 props 选项来声明：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: [<span class="string">'foo'</span>],</span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    <span class="comment">// setup() 接收 props 作为第一个参数</span></span><br><span class="line">    <span class="built_in">console</span>.log(props.foo)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了使用字符串数组来声明 props 外，还可以使用对象的形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 &lt;script setup&gt;</span></span><br><span class="line">defineProps(&#123;</span><br><span class="line">  title: <span class="built_in">String</span>,</span><br><span class="line">  likes: <span class="built_in">Number</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非 &lt;script setup&gt;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    title: <span class="built_in">String</span>,</span><br><span class="line">    likes: <span class="built_in">Number</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于以对象形式声明的每个属性，<strong>key 是 prop 的名称，而值则是该 prop 预期类型的构造函数</strong>。</p>
<p>如果搭配 TypeScript 使用 <code>&lt;script setup&gt;</code>，也可以使用类型标注来声明 props：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">defineProps&lt;&#123;</span><br><span class="line">  title?: string</span><br><span class="line">  likes?: number</span><br><span class="line">&#125;&gt;()</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="响应式-Props-解构"><a href="#响应式-Props-解构" class="headerlink" title="响应式 Props 解构"></a>响应式 Props 解构</h2><p>Vue 的响应系统基于属性访问跟踪状态的使用情况。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; foo &#125; = defineProps([<span class="string">'foo'</span>])</span><br><span class="line"></span><br><span class="line">watchEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在 3.5 之前只运行一次</span></span><br><span class="line">  <span class="comment">// 在 3.5+ 中在 "foo" prop 变化时重新执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(foo)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在 3.4 及以下版本，foo 是一个实际的常量，永远不会改变。在 3.5 及以上版本，当在同一个 <code>&lt;script setup&gt;</code> 代码块中访问由 defineProps 解构的变量时，Vue 编译器会自动在前面添加 props.。因此，上面的代码等同于以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> props = defineProps([<span class="string">'foo'</span>])</span><br><span class="line"></span><br><span class="line">watchEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// `foo` 由编译器转换为 `props.foo`</span></span><br><span class="line">  <span class="built_in">console</span>.log(props.foo)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>此外，你可以使用 JavaScript 原生的默认值语法声明 props 默认值。这在使用基于类型的 props 声明时特别有用。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; foo = <span class="string">'hello'</span> &#125; = defineProps&lt;&#123; foo?: <span class="built_in">string</span> &#125;&gt;()</span><br></pre></td></tr></table></figure>

<h3 id="将解构的-props-传递到函数中时注意保持响应性"><a href="#将解构的-props-传递到函数中时注意保持响应性" class="headerlink" title="将解构的 props 传递到函数中时注意保持响应性"></a>将解构的 props 传递到函数中时注意保持响应性</h3><p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; foo &#125; = defineProps([<span class="string">'foo'</span>])</span><br><span class="line"></span><br><span class="line">watch(foo, <span class="comment">/* ... */</span>)</span><br></pre></td></tr></table></figure>

<p>这并不会按预期工作，因为它等价于 watch(props.foo, …)——我们给 watch 传递的是一个值而不是响应式数据源。</p>
<p><strong>可以通过将其包装在 getter 中来侦听解构的 prop</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch(<span class="function"><span class="params">()</span> =&gt;</span> foo, <span class="comment">/* ... */</span>)</span><br></pre></td></tr></table></figure>

<p>当我们需要传递解构的 prop 到外部函数中并保持响应性时，这也是推荐做法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useComposable(<span class="function"><span class="params">()</span> =&gt;</span> foo)</span><br></pre></td></tr></table></figure>

<h2 id="传递-prop-时要注意的细节"><a href="#传递-prop-时要注意的细节" class="headerlink" title="传递 prop 时要注意的细节"></a>传递 prop 时要注意的细节</h2><h3 id="Prop-名字格式"><a href="#Prop-名字格式" class="headerlink" title="Prop 名字格式"></a>Prop 名字格式</h3><p><strong>prop 的名字应使用 camelCase 形式</strong>，因为它们是合法的 JavaScript 标识符，可以直接在模板的表达式中使用，也可以避免在作为属性 key 名时必须加上引号。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">defineProps(&#123;</span><br><span class="line">  greetingMessage: <span class="built_in">String</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>在向子组件传递 props 时，推荐将其写为 kebab-case 形式</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent greeting-message&#x3D;&quot;hello&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="传递不同的值类型"><a href="#传递不同的值类型" class="headerlink" title="传递不同的值类型"></a>传递不同的值类型</h3><p>任何类型的值都可以作为 props 的值被传递。包括：Number、Boolean、Array、Object。</p>
<h3 id="使用一个对象绑定多个-prop"><a href="#使用一个对象绑定多个-prop" class="headerlink" title="使用一个对象绑定多个 prop"></a>使用一个对象绑定多个 prop</h3><p>如果你想要将一个对象的所有属性都当作 props 传入，你可以使用没有参数的 v-bind。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> post = &#123;</span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  title: <span class="string">'My Journey with Vue'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;BlogPost v-bind&#x3D;&quot;post&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>这实际上等价于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;BlogPost :id&#x3D;&quot;post.id&quot; :title&#x3D;&quot;post.title&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h2><p>所有的 props 都遵循着单向绑定原则，props 因父组件的更新而变化，自然地将新的状态向下流往子组件，而不会逆向传递。这避免了子组件意外修改父组件的状态的情况，不然应用的数据流将很容易变得混乱而难以理解。</p>
<p><strong>注意：每次父组件更新后，所有的子组件中的 props 都会被更新到最新值，不应该在子组件中去更改一个 prop</strong>。若你这么做了，Vue 会在控制台上向你抛出警告。</p>
<p>可能更改一个 prop 的需求通常来源于以下两种场景：</p>
<ol>
<li>prop 被用于传入初始值；而子组件想在之后将其作为一个局部数据属性。</li>
</ol>
<p>在这种情况下，最好是新定义一个局部数据属性，从 props 上获取初始值即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> props = defineProps([<span class="string">'initialCounter'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数器只是将 props.initialCounter 作为初始值</span></span><br><span class="line"><span class="comment">// 像下面这样做就使 prop 和后续更新无关了</span></span><br><span class="line"><span class="keyword">const</span> counter = ref(props.initialCounter)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>需要对传入的 prop 值做进一步的转换。在这种情况中，最好是基于该 prop 值定义一个计算属性：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> props = defineProps([<span class="string">'size'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该 prop 变更时计算属性也会自动更新</span></span><br><span class="line"><span class="keyword">const</span> normalizedSize = computed(<span class="function"><span class="params">()</span> =&gt;</span> props.size.trim().toLowerCase())</span><br></pre></td></tr></table></figure>

<h3 id="更改对象-数组类型的-props"><a href="#更改对象-数组类型的-props" class="headerlink" title="更改对象 / 数组类型的 props"></a>更改对象 / 数组类型的 props</h3><p>当对象或数组作为 props 被传入时，虽然子组件无法更改 props 绑定，但仍然可以更改对象或数组内部的值。这是因为 JavaScript 的对象和数组是按引用传递，对 Vue 来说，阻止这种更改需要付出的代价异常昂贵。</p>
<p>这种更改的主要缺陷是它允许了子组件以某种不明显的方式影响父组件的状态，可能会使数据流在将来变得更难以理解。<strong>在最佳实践中，你应该尽可能避免这样的更改，除非父子组件在设计上本来就需要紧密耦合。在大多数场景下，子组件应该抛出一个事件来通知父组件做出改变</strong>。</p>
<h2 id="Prop-校验"><a href="#Prop-校验" class="headerlink" title="Prop 校验"></a>Prop 校验</h2><p>要声明对 props 的校验，你可以向 defineProps() 宏提供一个带有 props 校验选项的对象，当 prop 的校验失败后，Vue 会抛出一个控制台警告 (在开发模式下)。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">defineProps(&#123;</span><br><span class="line">  <span class="comment">// 基础类型检查</span></span><br><span class="line">  <span class="comment">// （给出 `null` 和 `undefined` 值则会跳过任何类型检查）</span></span><br><span class="line">  propA: <span class="built_in">Number</span>,</span><br><span class="line">  <span class="comment">// 多种可能的类型</span></span><br><span class="line">  propB: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">  <span class="comment">// 必传，且为 String 类型</span></span><br><span class="line">  propC: &#123;</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">    required: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 必传但可为 null 的字符串</span></span><br><span class="line">  propD: &#123;</span><br><span class="line">    type: [<span class="built_in">String</span>, <span class="literal">null</span>],</span><br><span class="line">    required: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// Number 类型的默认值</span></span><br><span class="line">  propE: &#123;</span><br><span class="line">    type: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="number">100</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 对象类型的默认值</span></span><br><span class="line">  propF: &#123;</span><br><span class="line">    type: <span class="built_in">Object</span>,</span><br><span class="line">    <span class="comment">// 对象或数组的默认值</span></span><br><span class="line">    <span class="comment">// 必须从一个工厂函数返回。</span></span><br><span class="line">    <span class="comment">// 该函数接收组件所接收到的原始 prop 作为参数。</span></span><br><span class="line">    <span class="keyword">default</span>(rawProps) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">message</span>: <span class="string">'hello'</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 自定义类型校验函数</span></span><br><span class="line">  <span class="comment">// 在 3.4+ 中完整的 props 作为第二个参数传入</span></span><br><span class="line">  propG: &#123;</span><br><span class="line">    validator(value, props) &#123;</span><br><span class="line">      <span class="comment">// The value must match one of these strings</span></span><br><span class="line">      <span class="keyword">return</span> [<span class="string">'success'</span>, <span class="string">'warning'</span>, <span class="string">'danger'</span>].includes(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 函数类型的默认值</span></span><br><span class="line">  propH: &#123;</span><br><span class="line">    type: <span class="built_in">Function</span>,</span><br><span class="line">    <span class="comment">// 不像对象或数组的默认，这不是一个</span></span><br><span class="line">    <span class="comment">// 工厂函数。这会是一个用来作为默认值的函数</span></span><br><span class="line">    <span class="keyword">default</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'Default function'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>defineProps() 宏中的参数不可以访问 <code>&lt;script setup&gt;</code> 中定义的其他变量，因为在编译时整个表达式都会被移到外部的函数中。</li>
<li>所有 prop 默认都是可选的，除非声明了 required: true。</li>
<li>除 Boolean 外的未传递的可选 prop 将会有一个默认值 undefined。</li>
<li>Boolean 类型的未传递 prop 将被转换为 false。这可以通过为它设置 default 来更改——例如：设置为 default: undefined 将与非布尔类型的 prop 的行为保持一致。</li>
<li>如果声明了 default 值，那么在 prop 的值被解析为 undefined 时，无论 prop 是未被传递还是显式指明的 undefined，都会改为 default 值。</li>
</ul>
<h3 id="运行时类型检查"><a href="#运行时类型检查" class="headerlink" title="运行时类型检查"></a>运行时类型检查</h3><p>校验选项中的 type 可以是下列这些原生构造函数：</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Array</li>
<li>Object</li>
<li>Date</li>
<li>Function</li>
<li>Symbol</li>
<li>Error</li>
</ul>
<p>另外，type 也可以是自定义的类或构造函数，Vue 将会通过 instanceof 来检查类型是否匹配。例如下面这个类：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(firstName, lastName) &#123;</span><br><span class="line">    <span class="keyword">this</span>.firstName = firstName</span><br><span class="line">    <span class="keyword">this</span>.lastName = lastName</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defineProps(&#123;</span><br><span class="line">  author: Person</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="可为-null-的类型"><a href="#可为-null-的类型" class="headerlink" title="可为 null 的类型"></a>可为 null 的类型</h3><p>如果该类型是必传但可为 null 的，你可以用一个包含 null 的数组语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">defineProps(&#123;</span><br><span class="line">  id: &#123;</span><br><span class="line">    type: [<span class="built_in">String</span>, <span class="literal">null</span>],</span><br><span class="line">    required: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>注意如果 type 仅为 null 而非使用数组语法，它将允许任何类型。</p>
<h3 id="Boolean-类型转换"><a href="#Boolean-类型转换" class="headerlink" title="Boolean 类型转换"></a>Boolean 类型转换</h3><p>为了更贴近原生 boolean attributes 的行为，声明为 Boolean 类型的 props 有特别的类型转换规则。以带有如下声明的 <MyComponent> 组件为例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">defineProps(&#123;</span><br><span class="line">  disabled: <span class="built_in">Boolean</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>该组件可以被这样使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 等同于传入 :disabled&#x3D;&quot;true&quot; --&gt;</span><br><span class="line">&lt;MyComponent disabled &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 等同于传入 :disabled&#x3D;&quot;false&quot; --&gt;</span><br><span class="line">&lt;MyComponent &#x2F;&gt;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2025/04/25/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Will Wan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Will's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/25/Vue3%E4%BE%A6%E5%90%AC%E5%99%A8/" class="post-title-link" itemprop="url">Vue3侦听器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-04-25 15:37:41 / 修改时间：17:31:16" itemprop="dateCreated datePublished" datetime="2025-04-25T15:37:41+08:00">2025-04-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在组合式 API 中，可以使用 watch 函数在每次响应式状态发生变化时触发回调函数。</p>
<h2 id="侦听数据源类型"><a href="#侦听数据源类型" class="headerlink" title="侦听数据源类型"></a>侦听数据源类型</h2><p>watch 的第一个参数可以是不同形式的“数据源”：它可以是一个 ref (包括计算属性)、一个响应式对象、一个 getter 函数、或多个数据源组成的数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = ref(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> y = ref(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单个 ref</span></span><br><span class="line">watch(x, (newX) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`x is <span class="subst">$&#123;newX&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// getter 函数</span></span><br><span class="line">watch(</span><br><span class="line">  () =&gt; x.value + y.value,</span><br><span class="line">  (sum) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`sum of x + y is: <span class="subst">$&#123;sum&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个来源组成的数组</span></span><br><span class="line">watch([x, () =&gt; y.value], ([newX, newY]) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`x is <span class="subst">$&#123;newX&#125;</span> and y is <span class="subst">$&#123;newY&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>注意，你不能直接侦听响应式对象的属性值，需要用一个返回该属性的 getter 函数</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = reactive(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，因为 watch() 得到的参数是一个 number</span></span><br><span class="line">watch(obj.count, (count) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Count is: <span class="subst">$&#123;count&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供一个 getter 函数</span></span><br><span class="line">watch(</span><br><span class="line">  () =&gt; obj.count,</span><br><span class="line">  (count) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Count is: <span class="subst">$&#123;count&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="深层侦听器"><a href="#深层侦听器" class="headerlink" title="深层侦听器"></a>深层侦听器</h2><p>直接给 watch() 传入一个响应式对象，会隐式地创建一个深层侦听器——该回调函数在所有嵌套的变更时都会被触发：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = reactive(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line">watch(obj, (newValue, oldValue) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 在嵌套的属性变更时触发</span></span><br><span class="line">  <span class="comment">// 注意：`newValue` 此处和 `oldValue` 是相等的</span></span><br><span class="line">  <span class="comment">// 因为它们是同一个对象！</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.count++</span><br></pre></td></tr></table></figure>

<p>监听一个返回响应式对象的 getter 函数，只有在返回不同的对象时，才会触发回调：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">watch(</span><br><span class="line">  () =&gt; state.someObject,</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 仅当 state.someObject 被替换时触发</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>也可以给上面这个例子显式地加上 <code>deep</code> 选项，强制转成深层侦听器：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">watch(</span><br><span class="line">  () =&gt; state.someObject,</span><br><span class="line">  (newValue, oldValue) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 注意：`newValue` 此处和 `oldValue` 是相等的</span></span><br><span class="line">    <span class="comment">// *除非* state.someObject 被整个替换了</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">deep</span>: <span class="literal">true</span> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在 Vue 3.5+ 中，deep 选项还可以是一个数字，表示最大遍历深度。</p>
<h2 id="即时回调的侦听器"><a href="#即时回调的侦听器" class="headerlink" title="即时回调的侦听器"></a>即时回调的侦听器</h2><p>watch 默认是懒执行的：仅当数据源变化时，才会执行回调。可以通过传入 <code>immediate: true</code> 选项来强制侦听器的回调立即执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">watch(</span><br><span class="line">  source,</span><br><span class="line">  (newValue, oldValue) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 立即执行，且当 `source` 改变时再次执行</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">immediate</span>: <span class="literal">true</span> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="一次性侦听器"><a href="#一次性侦听器" class="headerlink" title="一次性侦听器"></a>一次性侦听器</h2><p>如果希望回调只在源变化时触发一次，请使用 <code>once: true</code> 选项。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">watch(</span><br><span class="line">  source,</span><br><span class="line">  (newValue, oldValue) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 当 `source` 变化时，仅触发一次</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">once</span>: <span class="literal">true</span> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect()"></a>watchEffect()</h2><p><code>watchEffect</code> 和 <code>watch</code> 都能响应式地执行有副作用的回调。</p>
<p>例如下面的代码，在每当 todoId 的引用发生变化时使用侦听器来加载一个远程资源：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> todoId = ref(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> data = ref(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">watch(</span><br><span class="line">  todoId,</span><br><span class="line">  <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(</span><br><span class="line">      <span class="string">`https://jsonplaceholder.typicode.com/todos/<span class="subst">$&#123;todoId.value&#125;</span>`</span></span><br><span class="line">    )</span><br><span class="line">    data.value = <span class="keyword">await</span> response.json()</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">immediate</span>: <span class="literal">true</span> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>像上面例子中这样如果侦听器的回调中使用与源完全相同的响应式状态，就可以用 watchEffect 函数 来简化上面的代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">watchEffect(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(</span><br><span class="line">    <span class="string">`https://jsonplaceholder.typicode.com/todos/<span class="subst">$&#123;todoId.value&#125;</span>`</span></span><br><span class="line">  )</span><br><span class="line">  data.value = <span class="keyword">await</span> response.json()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="watch-vs-watchEffect"><a href="#watch-vs-watchEffect" class="headerlink" title="watch vs. watchEffect"></a>watch vs. watchEffect</h3><p>watch 和 watchEffect 之间的主要区别是追踪响应式依赖的方式：</p>
<ul>
<li><p>watch 只追踪明确侦听的数据源。它不会追踪任何在回调中访问到的东西。另外，仅在数据源确实改变时才会触发回调。watch 会避免在发生副作用时追踪依赖，因此，我们能更加精确地控制回调函数的触发时机。</p>
</li>
<li><p>watchEffect，则会在副作用发生期间追踪依赖。它会在同步执行过程中，自动追踪所有能访问到的响应式属性。这更方便，而且代码往往更简洁，但有时其响应性依赖关系会不那么明确。</p>
</li>
</ul>
<h2 id="副作用清理"><a href="#副作用清理" class="headerlink" title="副作用清理"></a>副作用清理</h2><p>当我们可能会在侦听器中执行副作用时，例如异步请求，如果在请求完成之前监听的数据源发生了变化，当上一个请求完成时，它仍会使用已经过时的数据源值触发回调。理想情况下，我们希望能够在数据源变为新值时取消过时的请求。</p>
<ol>
<li>可以使用<code>onWatcherCleanup()</code> API 来注册一个清理函数清理副作用：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; watch, onWatcherCleanup &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line">watch(id, (newId) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> controller = <span class="keyword">new</span> AbortController()</span><br><span class="line"></span><br><span class="line">  fetch(<span class="string">`/api/<span class="subst">$&#123;newId&#125;</span>`</span>, &#123; <span class="attr">signal</span>: controller.signal &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 回调逻辑</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  onWatcherCleanup(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 终止过期请求</span></span><br><span class="line">    controller.abort()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>注意，onWatcherCleanup 仅在 Vue 3.5+ 中支持，并且必须在 watchEffect 效果函数或 watch 回调函数的同步执行期间调用：你不能在异步函数的 await 语句之后调用它。</strong></p>
<ol start="2">
<li>在 Vue 3.5 之前的版本，可以使用 onCleanup 函数清理副作用。</li>
</ol>
<p>onCleanup 函数需要作为第三个参数传递给侦听器 watch 的回调函数，或 watchEffect 回调函数的第一个参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">watch(id, (newId, oldId, onCleanup) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  onCleanup(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 清理逻辑</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">watchEffect(<span class="function">(<span class="params">onCleanup</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  onCleanup(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 清理逻辑</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>通过函数参数传递的 onCleanup 与侦听器实例相绑定，因此不受 onWatcherCleanup 的同步限制。</p>
<h2 id="侦听器回调的触发时机"><a href="#侦听器回调的触发时机" class="headerlink" title="侦听器回调的触发时机"></a>侦听器回调的触发时机</h2><p>类似于组件更新，侦听器回调函数也会被批量处理以避免重复调用。默认情况下，<strong>侦听器回调会在父组件更新 (如有) 之后、所属组件的 DOM 更新之前被调用</strong>。</p>
<p>如果想在侦听器回调中能访问被 Vue 更新之后的所属组件的 DOM，需要指明 flush: ‘post’ 选项：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">watch(source, callback, &#123;</span><br><span class="line">  flush: <span class="string">'post'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">watchEffect(callback, &#123;</span><br><span class="line">  flush: <span class="string">'post'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="后置侦听器-watchPostEffect"><a href="#后置侦听器-watchPostEffect" class="headerlink" title="后置侦听器 watchPostEffect()"></a>后置侦听器 watchPostEffect()</h3><p>后置刷新的 watchEffect() 有个更方便的别名 watchPostEffect()：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; watchPostEffect &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line">watchPostEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* 在 Vue 更新后执行 */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="同步侦听器"><a href="#同步侦听器" class="headerlink" title="同步侦听器"></a>同步侦听器</h3><p>还可以创建一个同步触发的侦听器，它会在 Vue 进行任何更新之前触发：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">watch(source, callback, &#123;</span><br><span class="line">  flush: <span class="string">'sync'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">watchEffect(callback, &#123;</span><br><span class="line">  flush: <span class="string">'sync'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>同步触发的 watchEffect() 也有个更方便的别名 watchSyncEffect()：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; watchSyncEffect &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line">watchSyncEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* 在响应式数据变化时同步执行 */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>同步侦听器不会进行批处理，每当检测到响应式数据发生变化时就会触发。可以使用它来监视简单的布尔值，但应避免在可能多次同步修改的数据源 (如数组) 上使用。</strong></p>
<h2 id="停止侦听器"><a href="#停止侦听器" class="headerlink" title="停止侦听器"></a>停止侦听器</h2><p>在 setup() 或 <code>&lt;script setup&gt;</code> 中用同步语句创建的侦听器，会自动绑定到宿主组件实例上，并且会在宿主组件卸载时自动停止。</p>
<p>侦听器必须用同步语句创建：如果用异步回调创建一个侦听器，那么它不会绑定到当前组件上，必须手动停止它，以防内存泄漏。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; watchEffect &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 它会自动停止</span></span><br><span class="line">watchEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...这个则不会！</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  watchEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">&#125;, <span class="number">100</span>)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>要手动停止一个侦听器，请调用 watch 或 watchEffect 返回的函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unwatch = watchEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...当该侦听器不再需要时</span></span><br><span class="line">unwatch()</span><br></pre></td></tr></table></figure>

<p><strong>注意，需要异步创建侦听器的情况很少，请尽可能选择同步创建。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2025/04/24/Vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Will Wan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Will's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/24/Vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Vue3响应式基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-04-24 14:49:42 / 修改时间：18:15:09" itemprop="dateCreated datePublished" datetime="2025-04-24T14:49:42+08:00">2025-04-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="声明响应式状态"><a href="#声明响应式状态" class="headerlink" title="声明响应式状态"></a>声明响应式状态</h2><p>在组合式 API 中，推荐使用 ref() 函数来声明响应式状态。<strong>ref() 接收参数，并将其包裹在一个带有 .value 属性的 ref 对象中返回，所以在访问ref对象的值时需要通过 <code>.value</code> 属性访问</strong>。要在组件模板中访问 ref，需要从组件的 setup() 函数中声明并返回它们。<strong>注意，在模板中使用 ref 时，不需要附加 .value。这是因为为了方便起见，当在模板中使用时，ref 会自动解包</strong> 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 在 JavaScript 中需要 .value</span></span><br><span class="line">      count.value++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不要忘记同时暴露 increment 函数</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count,</span><br><span class="line">      increment</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click&#x3D;&quot;increment&quot;&gt;</span><br><span class="line">  &#123;&#123; count &#125;&#125;</span><br><span class="line">&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>

<h3 id="lt-script-setup-gt"><a href="#lt-script-setup-gt" class="headerlink" title="&lt;script setup&gt;"></a><code>&lt;script setup&gt;</code></h3><p>在 setup() 函数中手动暴露大量的状态和方法非常繁琐。所以框架提供了 <code>&lt;script setup&gt;</code> 来简化代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#39;vue&#39;</span><br><span class="line"></span><br><span class="line">const count &#x3D; ref(0)</span><br><span class="line"></span><br><span class="line">function increment() &#123;</span><br><span class="line">  count.value++</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click&#x3D;&quot;increment&quot;&gt;</span><br><span class="line">    &#123;&#123; count &#125;&#125;</span><br><span class="line">  &lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;script setup&gt;</code> 中的顶层的导入、声明的变量和函数可在同一组件的模板中直接使用。可以简单理解为它们是在模板同一作用域内声明的。</p>
<h3 id="为什么需要使用带有-value-的-ref？"><a href="#为什么需要使用带有-value-的-ref？" class="headerlink" title="为什么需要使用带有 .value 的 ref？"></a>为什么需要使用带有 .value 的 ref？</h3><p>为了实现响应式数据发生变化时，能自动检测到这个变化，并且相应地更新 DOM。vue要在组件首次渲染时追踪渲染过程中使用的每一个ref。然后，当一个 ref 被修改时，触发追踪它的组件的一次重新渲染。</p>
<p>在标准的 JavaScript 中，检测普通变量的访问或修改是行不通的。不过，可以通过 ref 的 getter 和 setter 方法来拦截对象属性的 get 和 set 操作。</p>
<p>这就给了 Vue 一个机会来检测 ref 何时被访问或修改。在其内部，Vue 在它的 getter 中执行追踪，在它的 setter 中执行触发。从概念上讲，可以将 ref 看作是一个像这样的对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码，不是真正的实现</span></span><br><span class="line"><span class="keyword">const</span> myRef = &#123;</span><br><span class="line">  _value: <span class="number">0</span>,</span><br><span class="line">  <span class="keyword">get</span> value() &#123;</span><br><span class="line">    track()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._value</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> value(newValue) &#123;</span><br><span class="line">    <span class="keyword">this</span>._value = newValue</span><br><span class="line">    trigger()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="深层响应性"><a href="#深层响应性" class="headerlink" title="深层响应性"></a>深层响应性</h3><p>Ref 可以持有任何类型的值，包括深层嵌套的对象、数组或者 JavaScript 内置的数据结构。</p>
<p>Ref 会使它的值具有深层响应性。这意味着即使改变嵌套对象或数组时，变化也会被检测到：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = ref(&#123;</span><br><span class="line">  nested: &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;,</span><br><span class="line">  arr: [<span class="string">'foo'</span>, <span class="string">'bar'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mutateDeeply</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 以下都会按照期望工作</span></span><br><span class="line">  obj.value.nested.count++</span><br><span class="line">  obj.value.arr.push(<span class="string">'baz'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以通过 shallowRef() 来放弃深层响应性。对于浅层 ref，只有 .value 的访问会被追踪。<strong>浅层 ref 可以用于避免对大型数据的响应性开销来优化性能、或者有外部库管理其内部状态的情况</strong>。</p>
<h3 id="DOM-更新时机"><a href="#DOM-更新时机" class="headerlink" title="DOM 更新时机"></a>DOM 更新时机</h3><p>修改了响应式状态时，DOM 会被自动更新。但是<strong>DOM 更新不是同步的</strong>。Vue 会在“next tick”更新周期中缓冲所有状态的修改，以确保不管进行了多少次状态修改，每个组件都只会被更新一次。</p>
<p>如果要等待 DOM 更新完成后再执行额外的代码，可以使用 nextTick() 全局 API：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; nextTick &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  count.value++</span><br><span class="line">  <span class="keyword">await</span> nextTick()</span><br><span class="line">  <span class="comment">// 现在 DOM 已经更新了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="reactive"><a href="#reactive" class="headerlink" title="reactive()"></a><code>reactive()</code></h2><p>另一种声明响应式状态的方式，即使用 <code>reactive()</code> API。与将内部值包装在特殊对象中的 ref 不同，<code>reactive()</code> 将使对象本身具有响应性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br></pre></td></tr></table></figure>

<p>在模板中使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click&#x3D;&quot;state.count++&quot;&gt;</span><br><span class="line">  &#123;&#123; state.count &#125;&#125;</span><br><span class="line">&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>

<p>响应式对象是 <strong>JavaScript 代理</strong>，其行为就和普通对象一样。不同的是，Vue 能够拦截对响应式对象所有属性的访问和修改，以便进行依赖追踪和触发更新。</p>
<p>reactive() 将深层地转换对象：当访问嵌套对象时，它们也会被 reactive() 包装。当 ref 的值是一个对象时，ref() 也会在内部调用它。<strong>与浅层 ref 类似，这里也有一个 shallowReactive() API 可以选择退出深层响应性。</strong></p>
<h3 id="响应式代理对象-vs-原始对象"><a href="#响应式代理对象-vs-原始对象" class="headerlink" title="响应式代理对象 vs. 原始对象"></a>响应式代理对象 vs. 原始对象</h3><p>reactive() 返回的是一个原始对象的 Proxy，它和原始对象是不相等的。只有代理对象是响应式的，更改原始对象不会触发更新。因此，使用 Vue 的响应式系统的<strong>最佳实践是仅使用你声明对象的代理版本</strong>。</p>
<p><strong>为保证访问代理的一致性，对同一个原始对象调用 reactive() 会总是返回同样的代理对象，而对一个已存在的代理对象调用 reactive() 会返回其本身</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> raw = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = reactive(raw)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理对象和原始对象不是全等的</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy === raw) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在同一个对象上调用 reactive() 会返回相同的代理</span></span><br><span class="line"><span class="built_in">console</span>.log(reactive(raw) === proxy) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在一个代理上调用 reactive() 会返回它自己</span></span><br><span class="line"><span class="built_in">console</span>.log(reactive(proxy) === proxy) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>依靠深层响应性，响应式对象内的嵌套对象依然是代理，因此响应式对象的嵌套对象和嵌套对象的原始对象也不相等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = reactive(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> raw = &#123;&#125;</span><br><span class="line">proxy.nested = raw</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.nested === raw) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="reactive-的局限性"><a href="#reactive-的局限性" class="headerlink" title="reactive() 的局限性"></a>reactive() 的局限性</h3><ol>
<li><p><strong>有限的值类型</strong>：它只能用于对象类型 (对象、数组和如 Map、Set 这样的集合类型)。</p>
</li>
<li><p><strong>不能替换整个对象</strong>：由于 Vue 的响应式跟踪是通过属性访问实现的，因此我们必须始终保持对响应式对象的相同引用。这意味着我们不能地“替换”响应式对象，因为这样的话与第一个引用的响应性连接将丢失。</p>
</li>
<li><p><strong>对解构操作不友好</strong>：当我们将响应式对象的原始类型属性解构为本地变量时，或者将该属性传递给函数时，我们将丢失响应性连接。</p>
</li>
</ol>
<p>由于这些限制，<strong>建议使用 ref() 作为声明响应式状态的主要 API</strong>。</p>
<h2 id="额外的-ref-解包细节"><a href="#额外的-ref-解包细节" class="headerlink" title="额外的 ref 解包细节"></a>额外的 ref 解包细节</h2><h3 id="ref-会在作为响应式对象的属性被访问或修改时自动解包"><a href="#ref-会在作为响应式对象的属性被访问或修改时自动解包" class="headerlink" title="ref 会在作为响应式对象的属性被访问或修改时自动解包"></a>ref 会在作为响应式对象的属性被访问或修改时自动解包</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">  count</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(state.count) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">state.count = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(count.value) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>如果将一个新的 ref 赋值给一个关联了已有 ref 的属性，那么它会替换掉旧的 ref：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> otherCount = ref(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">state.count = otherCount</span><br><span class="line"><span class="built_in">console</span>.log(state.count) <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 原始 ref 现在已经和 state.count 失去联系</span></span><br><span class="line"><span class="built_in">console</span>.log(count.value) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p><strong>只有当嵌套在一个深层响应式对象内时，才会发生 ref 解包</strong>。当其作为浅层响应式对象的属性被访问时不会解包。</p>
<h2 id="当-ref-作为响应式数组或原生集合类型-如-Map-中的元素被访问时，它不会被解包"><a href="#当-ref-作为响应式数组或原生集合类型-如-Map-中的元素被访问时，它不会被解包" class="headerlink" title="当 ref 作为响应式数组或原生集合类型 (如 Map) 中的元素被访问时，它不会被解包"></a>当 ref 作为响应式数组或原生集合类型 (如 Map) 中的元素被访问时，它不会被解包</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> books = reactive([ref(<span class="string">'Vue 3 Guide'</span>)])</span><br><span class="line"><span class="comment">// 这里需要 .value</span></span><br><span class="line"><span class="built_in">console</span>.log(books[<span class="number">0</span>].value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = reactive(<span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'count'</span>, ref(<span class="number">0</span>)]]))</span><br><span class="line"><span class="comment">// 这里需要 .value</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">'count'</span>).value)</span><br></pre></td></tr></table></figure>

<h3 id="在模板中解包的注意事项"><a href="#在模板中解包的注意事项" class="headerlink" title="在模板中解包的注意事项"></a>在模板中解包的注意事项</h3><h4 id="在模板渲染上下文中，只有顶级的-ref-属性才会被解包"><a href="#在模板渲染上下文中，只有顶级的-ref-属性才会被解包" class="headerlink" title="在模板渲染上下文中，只有顶级的 ref 属性才会被解包"></a>在模板渲染上下文中，只有顶级的 ref 属性才会被解包</h4><p>在下面的例子中，count 和 object 是顶级属性，但 object.id 不是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> object = &#123; <span class="attr">id</span>: ref(<span class="number">1</span>) &#125;</span><br></pre></td></tr></table></figure>

<p>因此，这个表达式将不会按预期工作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; object.id + 1 &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>渲染的结果将是 [object Object]1，因为在计算表达式时 object.id 没有被解包，仍然是一个 ref 对象。为了解决这个问题，我们可以将 id 解构为一个顶级属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; id &#125; = object</span><br></pre></td></tr></table></figure>

<h4 id="如果-ref-是文本插值的最终计算值，那么它将被解包"><a href="#如果-ref-是文本插值的最终计算值，那么它将被解包" class="headerlink" title="如果 ref 是文本插值的最终计算值，那么它将被解包"></a>如果 ref 是文本插值的最终计算值，那么它将被解包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 以下内容将渲染为 1： --&gt;</span><br><span class="line">&#123;&#123; object.id &#125;&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2025/04/21/script%20setup%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Will Wan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Will's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/21/script%20setup%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">script setup</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-04-21 18:24:45" itemprop="dateCreated datePublished" datetime="2025-04-21T18:24:45+08:00">2025-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-22 16:21:52" itemprop="dateModified" datetime="2025-04-22T16:21:52+08:00">2025-04-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>&lt;script setup&gt;</code> 是在单文件组件中使用组合式 API 的编译时语法糖。相比于普通的<code>&lt;script&gt;</code>语法，它具有更多优势：</p>
<ul>
<li>更少的样板内容，更简洁的代码。</li>
<li>能够使用纯 TypeScript 声明 props 和自定义事件。</li>
<li>更好的运行时性能 (其模板会被编译成同一作用域内的渲染函数，避免了渲染上下文代理对象)。</li>
<li>更好的 IDE 类型推导性能 (减少了语言服务器从代码中抽取类型的工作)。</li>
</ul>
<h2 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h2><p>要启用setup语法，只需要在<code>&lt;script&gt;</code>代码块上添加 <code>setup attribute</code>。顶层的变量和函数等会被暴露给模版，import 导入的内容也会暴露。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; capitalize &#125; from &#39;.&#x2F;helpers&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 变量</span><br><span class="line">const msg &#x3D; &#39;Hello!&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 函数</span><br><span class="line">function log() &#123;</span><br><span class="line">  console.log(msg)</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; capitalize(&#39;hello&#39;) &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;button @click&#x3D;&quot;log&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<h2 id="使用组件"><a href="#使用组件" class="headerlink" title="使用组件"></a>使用组件</h2><p><code>&lt;script setup&gt;</code>里的导入的组件可以直接作为自定义组件的标签名使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import MyComponent from &#39;.&#x2F;MyComponent.vue&#39;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;MyComponent &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>其 kebab-case 格式的 <my-component> 同样能在模板中使用。不过，官方强烈建议使用 PascalCase 格式以保持一致性。同时这也有助于区分原生的自定义元素。</p>
<h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><p>由于组件是通过变量引用而不是基于字符串组件名注册的，在 <code>&lt;script setup&gt;</code> 中要使用动态组件的时候，应该使用动态的 :is 来绑定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import Foo from &#39;.&#x2F;Foo.vue&#39;</span><br><span class="line">import Bar from &#39;.&#x2F;Bar.vue&#39;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;component :is&#x3D;&quot;Foo&quot; &#x2F;&gt;</span><br><span class="line">  &lt;component :is&#x3D;&quot;someCondition ? Foo : Bar&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<h3 id="递归组件"><a href="#递归组件" class="headerlink" title="递归组件"></a>递归组件</h3><p>一个单文件组件可以通过它的文件名被其自己所引用。例如：名为 FooBar.vue 的组件可以在其模板中用 <FooBar/> 引用它自己。</p>
<p><em>这种方式相比于导入的组件优先级更低。</em>如果有具名的导入和组件自身推导的名字冲突了，可以为导入的组件添加别名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; FooBar as FooBarChild &#125; from &#39;.&#x2F;components&#39;</span><br></pre></td></tr></table></figure>

<h2 id="使用自定义指令"><a href="#使用自定义指令" class="headerlink" title="使用自定义指令"></a>使用自定义指令</h2><p>本地的自定义指令在 <code>&lt;script setup&gt;</code> 中不需要显式注册，但他们必须遵循 vNameOfDirective 这样的命名规范：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const vMyDirective &#x3D; &#123;</span><br><span class="line">  beforeMount: (el) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 在元素上做些操作</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1 v-my-directive&gt;This is a Heading&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<h2 id="defineProps-和-defineEmits"><a href="#defineProps-和-defineEmits" class="headerlink" title="defineProps() 和 defineEmits()"></a>defineProps() 和 defineEmits()</h2><p>为了在声明 props 和 emits 选项时获得完整的类型推导支持，我们可以使用 defineProps 和 defineEmits API，它们自动地在 <code>&lt;script setup&gt;</code> 中可用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const props &#x3D; defineProps(&#123;</span><br><span class="line">  foo: String</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const emit &#x3D; defineEmits([&#39;change&#39;, &#39;delete&#39;])</span><br><span class="line">&#x2F;&#x2F; setup 代码</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>defineProps</code> 和 <code>defineEmits</code> 都是只能在 <code>&lt;script setup&gt;</code> 中使用的编译器宏。他们不需要导入，且会随着 <code>&lt;script setup&gt;</code> 的处理过程一同被编译掉。</p>
</li>
<li><p><code>defineProps</code> 和 <code>defineEmits</code> 在选项传入后，会提供恰当的类型推导。</p>
</li>
<li><p><strong>注意：传入的选项不能引用在 setup 作用域中声明的局部变量。因为传入到 <code>defineProps</code> 和 <code>defineEmits</code> 的选项会在编译阶段从 setup 中提升到模块的作用域（整个文件的顶层作用域），这样做会引起编译错误。</strong> 但是，它可以引用导入的绑定，因为导入的绑定也在模块作用域内。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">const localValue &#x3D; &quot;hello&quot;;</span><br><span class="line">import &#123; someConstant &#125; from &#39;.&#x2F;constants&#39;;</span><br><span class="line"></span><br><span class="line">defineProps(&#123;</span><br><span class="line">  msg: &#123;</span><br><span class="line">    type: String,</span><br><span class="line">    &#x2F;&#x2F; 错误！因为选项被提升到了模块作用域，无法访问 setup 内的局部变量</span><br><span class="line">    default: localValue</span><br><span class="line">  &#125;,</span><br><span class="line">  otherProp: &#123;</span><br><span class="line">    type: String,</span><br><span class="line">    &#x2F;&#x2F; 正确！导入的绑定位于模块作用域，可以被引用</span><br><span class="line">    default: someConstant</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://cn.vuejs.org/api/sfc-script-setup.html" target="_blank" rel="noopener">vue3官方文档——单文件组件<script setup></a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/05/23/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Will Wan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Will's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/23/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/" class="post-title-link" itemprop="url">多表查询</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-23 16:37:13" itemprop="dateCreated datePublished" datetime="2023-05-23T16:37:13+08:00">2023-05-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-24 18:15:09" itemprop="dateModified" datetime="2025-04-24T18:15:09+08:00">2025-04-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>指从多张表中查询数据。</p>
<h2 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h2><ul>
<li>一对多：在多的一方建立外键，指向一的一方的主键</li>
<li>多对多：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</li>
<li>一对一：在任意一方加入外键，关联另一方的主键，并且设置外键为唯一的（UNIQUE）。多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率</li>
</ul>
<h2 id="多表查询分类"><a href="#多表查询分类" class="headerlink" title="多表查询分类"></a>多表查询分类</h2><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><ul>
<li>内连接：查询两张表的交集部分数据。</li>
</ul>
<p>隐式内连接：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> employee e, department d <span class="keyword">where</span> e.dept_id = d.id;</span><br></pre></td></tr></table></figure>

<p>显式内连接：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> employee e, <span class="keyword">inner</span> <span class="keyword">join</span> department d <span class="keyword">on</span> e.dept_id = d.id;</span><br></pre></td></tr></table></figure>

<ul>
<li>外连接：</li>
</ul>
<p>左外连接：查询左表所有数据，以及两张表的交集部分数据数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> employee e, <span class="keyword">left</span> <span class="keyword">join</span> department d <span class="keyword">on</span> e.dept_id = d.id;</span><br></pre></td></tr></table></figure>

<p>右外连接：查询右表所有数据，以及两张表的交集部分数据数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> employee e, <span class="keyword">right</span> <span class="keyword">join</span> department d <span class="keyword">on</span> e.dept_id = d.id;</span><br></pre></td></tr></table></figure>

<ul>
<li>自连接：查询当前表和自身的连接查询，自连接必须使用别名。自连接可以是内连接，也可以是外连接</li>
</ul>
<p>内连接：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询员工及其所属领导的名字</span></span><br><span class="line"><span class="keyword">select</span> emp.name, mng.name <span class="keyword">from</span> employee emp, employee mng <span class="keyword">on</span> emp.manager_id = mng.id;</span><br></pre></td></tr></table></figure>

<p>外连接：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询员工及其所属领导的名字，员工没有领导也要查询出来</span></span><br><span class="line"><span class="keyword">select</span> emp.name, mng.name <span class="keyword">from</span> employee emp <span class="keyword">left</span> <span class="keyword">join</span> employee mng <span class="keyword">on</span> emp.manager_id = mng.id;</span><br></pre></td></tr></table></figure>

<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/06/vue3%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Will Wan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Will's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/06/vue3%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">vue3项目总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-06 19:43:30" itemprop="dateCreated datePublished" datetime="2022-04-06T19:43:30+08:00">2022-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-22 16:19:51" itemprop="dateModified" datetime="2025-04-22T16:19:51+08:00">2025-04-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基础变化"><a href="#基础变化" class="headerlink" title="基础变化"></a>基础变化</h2><ul>
<li><p>vue3 全家桶使用：和 vue2 的相比变化是 new 实例化改为 creatXXX，例如：new Vue() 改为 createApp()</p>
</li>
<li><p>注册组件：和 vue2 的相比变化是 Vue.component() 改为 根应用 app.component()</p>
</li>
</ul>
<h2 id="composition-组合式-API"><a href="#composition-组合式-API" class="headerlink" title="composition(组合式) API"></a>composition(组合式) API</h2><p>将同一个逻辑关注点相关代码放在一起。</p>
<h3 id="组合式API入口：setup"><a href="#组合式API入口：setup" class="headerlink" title="组合式API入口：setup"></a>组合式API入口：setup</h3><p>setup：在组件创建之前执行，setup 选项是一个接收 props 和 context 两个参数的函数。</p>
<h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><ul>
<li>props：</li>
</ul>
<p>和vue2一样，setup 函数中的 props 是响应式的，当传入新的 prop 时，它将被更新。</p>
<p><strong>因为是响应式的，所以不能使用 ES6 解构，它会消除 prop 的响应性。</strong></p>
<p>如果需要解构 prop，可以在 setup 函数中使用 toRefs 函数来完成此操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyBook.vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; toRefs &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line">setup(props) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; title &#125; = toRefs(props)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(title.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 title 是可选的 prop，则传入的 props 中可能没有 title 。在这种情况下，toRefs 将不会为 title 创建一个 ref 。你需要使用 toRef 替代它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyBook.vue</span></span><br><span class="line"><span class="keyword">import</span> &#123; toRef &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line">setup(props) &#123;</span><br><span class="line">  <span class="keyword">const</span> title = toRef(props, <span class="string">'title'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(title.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Context</li>
</ul>
<p>context 是一个普通 JavaScript 对象，暴露了其它可能在 setup 中有用的值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyBook.vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup(props, context) &#123;</span><br><span class="line">    <span class="comment">// Attribute (非响应式对象，等同于 $attrs)</span></span><br><span class="line">    <span class="built_in">console</span>.log(context.attrs)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插槽 (非响应式对象，等同于 $slots)</span></span><br><span class="line">    <span class="built_in">console</span>.log(context.slots)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发事件 (方法，等同于 $emit)</span></span><br><span class="line">    <span class="built_in">console</span>.log(context.emit)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴露公共 property (函数)</span></span><br><span class="line">    <span class="built_in">console</span>.log(context.expose)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>context 是一个普通的 JavaScript 对象，它不是响应式的，这意味着可以安全地对 context 使用 ES6 解构。</p>
<p>执行 setup 时，无法访问以下组件选项：</p>
<ul>
<li>data</li>
<li>computed</li>
<li>methods</li>
<li>refs (模板 ref)</li>
</ul>
<p><a href="https://v3.cn.vuejs.org/guide/composition-api-setup.html" target="_blank" rel="noopener">setup详细指南</a></p>
<h3 id="响应式变量"><a href="#响应式变量" class="headerlink" title="响应式变量"></a>响应式变量</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- MyBook.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; collectionName &#125;&#125;: &#123;&#123; readersNumber &#125;&#125; &#123;&#123; book.title &#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">import</span> &#123; ref, reactive &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      collectionName: <span class="built_in">String</span></span><br><span class="line">    &#125;,</span><br><span class="line">    setup(props) &#123;</span><br><span class="line">      <span class="comment">// 单个值</span></span><br><span class="line">      <span class="keyword">const</span> readersNumber = ref(<span class="number">0</span>)</span><br><span class="line">      <span class="comment">// 单个值取值要通过.value，在模板里会自动解包，可以不用手动获取。</span></span><br><span class="line">      <span class="built_in">console</span>.log(count.value) <span class="comment">// 0</span></span><br><span class="line">      <span class="comment">// 对象</span></span><br><span class="line">      <span class="keyword">const</span> book = reactive(&#123; <span class="attr">title</span>: <span class="string">'Vue 3 Guide'</span> &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 暴露给 template</span></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        readersNumber,</span><br><span class="line">        book</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://v3.cn.vuejs.org/api/reactivity-api.html" target="_blank" rel="noopener">更多响应性基础API</a></p>
<h3 id="在-setup-内定义和使用方法"><a href="#在-setup-内定义和使用方法" class="headerlink" title="在 setup 内定义和使用方法"></a>在 setup 内定义和使用方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/components/UserRepositories.vue</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref, onMounted &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在我们的组件中</span></span><br><span class="line">setup (props) &#123;</span><br><span class="line">  <span class="keyword">const</span> name = ref(<span class="string">''</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> setName = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">    name.value = str</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setName(<span class="string">'wan'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    setName</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在-setup-内注册生命周期钩子"><a href="#在-setup-内注册生命周期钩子" class="headerlink" title="在 setup 内注册生命周期钩子"></a>在 setup 内注册生命周期钩子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/components/UserRepositories.vue</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref, onMounted &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在我们的组件中</span></span><br><span class="line">setup (props) &#123;</span><br><span class="line">  <span class="keyword">const</span> repositories = ref([])</span><br><span class="line">  <span class="keyword">const</span> getUserRepositories = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    repositories.value = <span class="keyword">await</span> fetchUserRepositories(props.user)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onMounted(getUserRepositories) <span class="comment">// 在 `mounted` 时调用 `getUserRepositories`</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    repositories,</span><br><span class="line">    getUserRepositories</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下表包含如何在 setup () 内部调用生命周期钩子：</p>
<table>
<thead>
<tr>
<th>选项式 API</th>
<th>Hook inside setup</th>
</tr>
</thead>
<tbody><tr>
<td>beforeCreate</td>
<td>Not needed*</td>
</tr>
<tr>
<td>created</td>
<td>Not needed*</td>
</tr>
<tr>
<td>beforeMount</td>
<td>onBeforeMount</td>
</tr>
<tr>
<td>mounted</td>
<td>onMounted</td>
</tr>
<tr>
<td>beforeUpdate</td>
<td>onBeforeUpdate</td>
</tr>
<tr>
<td>updated</td>
<td>onUpdated</td>
</tr>
<tr>
<td>beforeUnmount</td>
<td>onBeforeUnmount</td>
</tr>
<tr>
<td>unmounted</td>
<td>onUnmounted</td>
</tr>
<tr>
<td>errorCaptured</td>
<td>onErrorCaptured</td>
</tr>
<tr>
<td>renderTracked</td>
<td>onRenderTracked</td>
</tr>
<tr>
<td>renderTriggered</td>
<td>onRenderTriggered</td>
</tr>
<tr>
<td>activated</td>
<td>onActivated</td>
</tr>
<tr>
<td>deactivated</td>
<td>onDeactivated</td>
</tr>
</tbody></table>
<h3 id="在-setup-内计算属性和侦听器"><a href="#在-setup-内计算属性和侦听器" class="headerlink" title="在 setup 内计算属性和侦听器"></a>在 setup 内计算属性和侦听器</h3><h4 id="computed：独立的计算属性"><a href="#computed：独立的计算属性" class="headerlink" title="computed：独立的计算属性"></a>computed：独立的计算属性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = ref(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> twiceTheCounter = computed(<span class="function"><span class="params">()</span> =&gt;</span> counter.value * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">counter.value++</span><br><span class="line"><span class="built_in">console</span>.log(counter.value) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(twiceTheCounter.value) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p><a href="https://v3.cn.vuejs.org/api/computed-watch-api.html#computed" target="_blank" rel="noopener">更多computed属性说明</a></p>
<h4 id="watchEffect-侦听器"><a href="#watchEffect-侦听器" class="headerlink" title="watchEffect 侦听器"></a>watchEffect 侦听器</h4><p>为了根据响应式状态自动应用和重新应用副作用，我们可以使用 watchEffect 函数。它立即执行传入的一个函数，同时响应式追踪其依赖，并在其依赖变更时重新运行该函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">watchEffect(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(count.value))</span><br><span class="line"><span class="comment">// -&gt; logs 0</span></span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  count.value++</span><br><span class="line">  <span class="comment">// -&gt; logs 1</span></span><br><span class="line">&#125;, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<h4 id="watch-侦听器"><a href="#watch-侦听器" class="headerlink" title="watch 侦听器"></a>watch 侦听器</h4><p>watch API 与选项式 API this.$watch (以及相应的 watch 选项) 完全等效。watch 需要侦听特定的数据源，并在单独的回调函数中执行副作用。默认情况下，它也是惰性的——即回调仅在侦听源发生变化时被调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = ref(<span class="number">0</span>)</span><br><span class="line">watch(counter, (newValue, oldValue) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'The new counter value is: '</span> + counter.value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>与 watchEffect 比较，watch 允许我们：</p>
<blockquote>
<p>懒执行副作用；<br>更具体地说明什么状态应该触发侦听器重新运行；<br>访问侦听状态变化前后的值。</p>
</blockquote>
<p><a href="https://v3.cn.vuejs.org/guide/reactivity-computed-watchers.html" target="_blank" rel="noopener">计算属性和侦听器详细指南</a></p>
<h3 id="模板引用"><a href="#模板引用" class="headerlink" title="模板引用"></a>模板引用</h3><p>在使用组合式 API 时，响应式引用和模板引用的概念是统一的。为了获得对模板内元素或组件实例的引用，我们可以像往常一样声明 ref 并从 setup() 返回：</p>
<p><strong>注意：板引用只会在初始渲染之后可以使用</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt; </span><br><span class="line">  &lt;div ref=<span class="string">"root"</span>&gt;This is a root element&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">import</span> &#123; ref, onMounted &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">      <span class="keyword">const</span> root = ref(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">      onMounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// DOM 元素将在初始渲染后分配给 ref</span></span><br><span class="line">        <span class="built_in">console</span>.log(root.value) <span class="comment">// &lt;div&gt;This is a root element&lt;/div&gt;</span></span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        root</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里我们在渲染上下文中暴露 root，并通过 ref=”root”，将其绑定到 div 作为其 ref。</p>
<p>在虚拟 DOM 补丁算法中，如果 VNode 的 ref 键对应于渲染上下文中的 ref，则 VNode 的相应元素或组件实例将被分配给该 ref 的值。这是在虚拟 DOM 挂载/打补丁过程中执行的，因此<strong>模板引用只会在初始渲染之后获得赋值</strong>。</p>
<p>作为模板使用的 ref 的行为与任何其他 ref 一样：它们是响应式的，可以传递到 (或从中返回) 复合函数中。</p>
<p><a href="https://v3.cn.vuejs.org/guide/composition-api-template-refs.html" target="_blank" rel="noopener">模板引用详细指南</a></p>
<h3 id="在-setup-内使用vuex"><a href="#在-setup-内使用vuex" class="headerlink" title="在 setup 内使用vuex"></a>在 setup 内使用vuex</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useStore &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> store = useStore()</span><br><span class="line">    <span class="keyword">const</span> onSubmit = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      store.dispatch(<span class="string">'user/Login'</span>, formState).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        router.push(<span class="string">'/index'</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="在-setup-内使用vue-router"><a href="#在-setup-内使用vue-router" class="headerlink" title="在 setup 内使用vue-router"></a>在 setup 内使用vue-router</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRouter, useRoute &#125; <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="comment">// 使用 router</span></span><br><span class="line">    <span class="keyword">const</span> router = useRouter();</span><br><span class="line">    router.push(<span class="string">"/user/login"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 route</span></span><br><span class="line">    <span class="keyword">const</span> route = useRoute();</span><br><span class="line">    <span class="built_in">console</span>.log(route.query)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>







      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/03/24/js%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Will Wan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Will's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/24/js%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">js事件模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-24 11:17:00" itemprop="dateCreated datePublished" datetime="2022-03-24T11:17:00+08:00">2022-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-02 12:07:12" itemprop="dateModified" datetime="2022-08-02T12:07:12+08:00">2022-08-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>当DOM元素上的发生某个事件时， 会产生一个事件对像 event，这个对象包含着与事件有关的所有信息。事件对象作为参数传给事件监听函数。浏览器原生提供一个Event对象，所有的事件都是这个对象的实例，或者说继承了Event.prototype对象。</p>
<h3 id="事件对象的跨浏览器兼容"><a href="#事件对象的跨浏览器兼容" class="headerlink" title="事件对象的跨浏览器兼容"></a>事件对象的跨浏览器兼容</h3><ul>
<li>获取事件对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event ? event : <span class="built_in">window</span>.event;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取事件目标</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = event || <span class="built_in">window</span>.event,</span><br><span class="line">  target = event.target || event.srcElement;</span><br></pre></td></tr></table></figure>

<ul>
<li>阻止事件默认事件</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = event || <span class="built_in">window</span>.event,</span><br><span class="line"><span class="keyword">if</span> (event.preventDefault)&#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    event.returnValue = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>阻止事件冒泡</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = event || <span class="built_in">window</span>.event,</span><br><span class="line"><span class="keyword">if</span> (event.stopPropagation)&#123;</span><br><span class="line">    event.stopPropagation();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h2><p>事件模型有三种：原始事件模型（DOM0 级）、标准事件模型（DOM2 级）、IE 事件模型</p>
<h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><p>DOM 结构是一个树型结构，当一个 HTML 元素发生一个事件时，该事件会在元素结点与根结点之间的路径传播，传播路径经过的结点都会接收到该事件，这个传播过程称为 DOM 事件流。</p>
<p>事件流共包含三个阶段：</p>
<ul>
<li>事件捕获阶段(capture phase)</li>
<li>处于目标阶段(target phase)</li>
<li>事件冒泡阶段(bubbling phase)</li>
</ul>
<h3 id="原始事件模型（DOM0-级）"><a href="#原始事件模型（DOM0-级）" class="headerlink" title="原始事件模型（DOM0 级）"></a>原始事件模型（DOM0 级）</h3><p>绑定事件监听函数：</p>
<ul>
<li>HTML 代码中直接绑定</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"fun()"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过 JS 代码绑定</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">".btn"</span>);</span><br><span class="line">btn.onclick = fun;</span><br></pre></td></tr></table></figure>

<p>移除事件监听函数方式：只要将对应事件属性置为 null 即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul>
<li>绑定速度快（但由于绑定速度太快，可能页面还未完全加载出来，以至于事件可能无法正常运行）</li>
<li>跨浏览器兼容性好</li>
<li>只支持冒泡，不支持捕获</li>
<li>同一个类型的事件只能绑定一次</li>
</ul>
<h3 id="标准事件模型（DOM2-级）"><a href="#标准事件模型（DOM2-级）" class="headerlink" title="标准事件模型（DOM2 级）"></a>标准事件模型（DOM2 级）</h3><p>在该事件模型中，一次事件共有三个阶段:</p>
<ul>
<li>事件捕获阶段：事件从 document 一直向下传播到目标元素, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行</li>
<li>处于目标阶段：事件到达目标元素, 触发目标元素的监听函数</li>
<li>事件冒泡阶段：事件从目标元素冒泡到 document, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行</li>
</ul>
<p>绑定事件监听函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addEventListener(eventType, handler, useCapture);</span><br></pre></td></tr></table></figure>

<p>移除事件监听函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">removeEventListener(eventType, handler, useCapture);</span><br></pre></td></tr></table></figure>

<ul>
<li>eventType: 指定事件类型(不要加 on)</li>
<li>handler: 事件监听函数</li>
<li>useCapture: 布尔值，表示监听函数是否在捕获阶段（capture）触发，默认为false（监听函数只在冒泡阶段被触发）。该参数可选。一般设置为 false 与 IE 浏览器保持一致。</li>
</ul>
<h4 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h4><ul>
<li>可以在一个 DOM 元素上绑定多个相同类型的事件监听函数</li>
<li>可以指定事件监听函数执行时机</li>
<li>兼容差，兼容 IE9+</li>
</ul>
<h3 id="IE-事件模型"><a href="#IE-事件模型" class="headerlink" title="IE 事件模型"></a>IE 事件模型</h3><p>IE 事件模型共有两个过程：</p>
<ul>
<li>处于目标阶段：事件到达目标元素, 触发目标元素的事件监听函数</li>
<li>事件冒泡阶段：事件从目标元素冒泡到 document, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行</li>
</ul>
<p>绑定事件监听函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">attachEvent(eventType, handler);</span><br></pre></td></tr></table></figure>

<p>移除事件监听函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">detachEvent(eventType, handler);</span><br></pre></td></tr></table></figure>

<h3 id="跨浏览器的事件监听程序"><a href="#跨浏览器的事件监听程序" class="headerlink" title="跨浏览器的事件监听程序"></a>跨浏览器的事件监听程序</h3><p>添加事件监听程序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addHandler</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">        element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">        element.attachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        element[<span class="string">"on"</span> + type] = handler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>移除事件监听程序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeHandler</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.removeListener) &#123;</span><br><span class="line">        element.removeListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</span><br><span class="line">        element.detachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">        element[<span class="string">"on"</span> + type] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>this指向：事件监听函数内部的this指向触发事件的那个元素节点。</strong></p>
<h2 id="事件的代理"><a href="#事件的代理" class="headerlink" title="事件的代理"></a>事件的代理</h2><p>由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>);</span><br><span class="line"></span><br><span class="line">ul.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.target.tagName.toLowerCase() === <span class="string">'li'</span>) &#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，click事件的监听函数定义在<code>&lt;ul&gt;</code>节点，但是实际上，它处理的是子节点<code>&lt;li&gt;</code>的click事件。</p>
<p>事件代理的好处：<strong>只要定义一个监听函数，就能处理多个子节点的事件。而且以后再添加子节点，监听函数依然有效。</strong></p>
<p>如果希望事件到某个节点为止，不再传播，可以使用事件对象的stopPropagation方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件传播到 p 元素后，就不再向下传播了</span></span><br><span class="line">p.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件冒泡到 p 元素后，就不再向上冒泡了</span></span><br><span class="line">p.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，stopPropagation方法分别在捕获阶段和冒泡阶段，阻止了事件的传播。</p>
<p><strong>但是，stopPropagation方法只会阻止事件的传播，不会阻止该事件触发<p>节点的其他click事件的监听函数。也就是说，不是彻底取消click事件。</strong></p>
<p>如果想要彻底阻止这个事件的传播，不再触发后面所有click的监听函数，可以使用stopImmediatePropagation方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.stopImmediatePropagation();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不会被触发</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="自定义事件（CustomEvent）-接口"><a href="#自定义事件（CustomEvent）-接口" class="headerlink" title="自定义事件（CustomEvent） 接口"></a>自定义事件（CustomEvent） 接口</h2><p>CustomEvent 接口用于生成自定义的事件实例。那些浏览器预定义的事件，虽然可以手动生成，但是往往不能在事件上绑定数据。如果需要在触发事件的同时，传入指定的数据，就可以使用 CustomEvent 接口生成的自定义事件对象。</p>
<p>浏览器原生提供CustomEvent()构造函数，用来生成 CustomEvent 事件实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> CustomEvent(type, options)</span><br></pre></td></tr></table></figure>

<ul>
<li>type：事件名称，必传。</li>
<li>options: 配置对象，可选。配置对象除了接受 Event 事件的配置属性，只有一个自己的属性。</li>
</ul>
<blockquote>
<p>detail：表示事件的附带数据，默认为null。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myEvent = <span class="keyword">new</span> CustomEvent(<span class="string">'myevent'</span>, &#123;</span><br><span class="line">  detail: &#123;</span><br><span class="line">    foo: <span class="string">'bar'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  bubbles: <span class="literal">true</span>, <span class="comment">// 布尔值，可选，默认为false，表示事件对象是否冒泡。</span></span><br><span class="line">  cancelable: <span class="literal">false</span> <span class="comment">// 可选，默认为false，表示事件是否可以被取消，即能否用</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">el.addEventListener(<span class="string">'myevent'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello '</span> + event.detail.foo);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">el.dispatchEvent(myEvent);</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://javascript.ruanyifeng.com/dom/event.html#toc12" target="_blank" rel="noopener">阮一峰javascript事件模型</a></li>
<li><a href="https://mp.weixin.qq.com/s/avXtM79vyywVq6Gg6ui29A" target="_blank" rel="noopener">JS每日一题javascript中的事件模型</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/03/08/TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Will Wan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Will's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/08/TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/" class="post-title-link" itemprop="url">TCP协议的三次握手和四次挥手</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-08 09:50:43" itemprop="dateCreated datePublished" datetime="2022-03-08T09:50:43+08:00">2022-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-02 12:07:12" itemprop="dateModified" datetime="2022-08-02T12:07:12+08:00">2022-08-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>地址：<a href="https://github.com/jawil/blog/issues/14" target="_blank" rel="noopener">https://github.com/jawil/blog/issues/14</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Will Wan"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Will Wan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Will Wan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
