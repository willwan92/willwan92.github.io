---
title: 字符串和编码
date: 2020-09-03 09:59:52
tags: ['字符串', '字符编码']
categories: ['python']
---

## 字符编码

字符编码一直是一个令我困惑的问题，直到我看了廖大神的[这篇文章](https://www.liaoxuefeng.com/wiki/1016959663602400/1017075323632896)。

## 字符串

在最新的Python 3版本中，**字符串是以Unicode编码的，支持多语言**，例如：

```py
>>> print('包含中文的str')
包含中文的str
```

### 访问字符串中的值

通过索引值可以访问子字符串

```py
>>> var1 = 'Hello World!'
>>> var2 = "Python Runoob"
>>> print(var1[0])
H
>>> print(var2[1:5])
ytho
```

### 字符串拼接

通过加号可以拼接多个字符串

```py
>>> var1 = 'Hello World!'
>>> print(var1[:6] + 'Runoob!')
Hello Runoob!
```

### 其他字符串运算符

- *: 重复输出字符串
- []: 通过索引获取字符串中字符
- [:]: 截取字符串中的一部分
- in: 成员运算符 - 如果字符串中包含给定的字符返回 True
- not in: 成员运算符 - 如果字符串中不包含给定的字符返回 True
- %: 格式字符串

### 单个字符的编解码
对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：

```py
>>> ord('A')
65
>>> ord('中')
20013
>>> chr(66)
'B'
>>> chr(25991)
'文'
```

### 用16进制写字符串

如果知道字符串的整数编码，还可以用十六进制这么写str：

```py
>>> '\u4e2d\u6587'
'中文'
```

### bytes类型和str类型转换

由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes（为了节省存储空间或者提高传输效率）。

bytes类型的数据用带b前缀的单引号或双引号表示：

```py
x = b'ABC'
```

要注意区分'ABC'和b'ABC'，虽然二者内容显示一样，但是前者是str，后者是bytes，bytes的每个字符都只占用一个字节。

以Unicode表示的str通过encode()方法可以编码为指定编码字符集的bytes，例如：

```py
>>> 'ABC'.encode('ascii')
b'ABC'
>>> '中文'.encode('utf-8')
b'\xe4\xb8\xad\xe6\x96\x87'
>>> '中文'.encode('ascii')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)
```

纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。

反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法：

```py
>>> b'ABC'.decode('ascii')
'ABC'
>>> b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')
'中文'
```

如果bytes中包含无法解码的字节，decode()方法会报错：

```py
>>> b'\xe4\xb8\xad\xff'.decode('utf-8')
Traceback (most recent call last):
  ...
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 3: invalid start byte
```

如果bytes中只有一小部分无效的字节，可以传入errors='ignore'忽略错误的字节：

```py
>>> b'\xe4\xb8\xad\xff'.decode('utf-8', errors='ignore')
'中'
```

#### 两种类型字符串的长度

要计算str包含多少个字符，可以用len()函数：

```py
>>> len('ABC')
3
>>> len('中文')
2
```

**len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数**：

```py
>>> len(b'ABC')
3
>>> len(b'\xe4\xb8\xad\xe6\x96\x87')
6
>>> len('中文'.encode('utf-8'))
6
```

可见，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。

在操作字符串时，我们经常遇到str和bytes的互相转换。为了避免乱码问题，**应当始终坚持使用UTF-8编码对str和bytes进行转换**。

#### 为python源代码文件添加编码注释

当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：

```py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
```

第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；

第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。

申明了UTF-8编码并不意味着你的.py文件就是UTF-8编码的，必须并且要确保文本编辑器正在使用UTF-8 without BOM编码。

### 格式化

#### 用 % 格式化

在python中，用`%`格式化字符串，和C语言是一致的：

```py
>>> 'Hello, %s' % 'world'
'Hello, world'
>>> 'Hi, %s, you have $%d.' % ('Michael', 1000000)
'Hi, Michael, you have $1000000.'
```

%运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。

常见的占位符有：

- 整数: %d
- 浮点数: %f
- 字符串: %s
- 十六进制整数: %x

其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数：

```py
>>> print('%02d-%03d' % (3, 1))
03-001
>>> print('%.2f' % 3.1415926)
3.14
>>>
```

如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串：

```py
>>> 'Age: %s. Gender: %s' % (25, True)
'Age: 25. Gender: True'
```

字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%：

```py
>>> 'growth rate: %d %%' % 7
'growth rate: 7 %'
```

#### format()

format()方法会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦：

```py
>>> 'Hello, {0}, 成绩提升了 {1:.1f}%'.format('小明', 17.125)
'Hello, 小明, 成绩提升了 17.1%'
```

#### f-string

使用以f开头的字符串，称之为f-string，它和普通字符串不同之处在于，字符串如果包含{xxx}，就会以对应的变量替换(**和js的模板字符串类似**)：

```py
>>> r = 2.5
>>> s = 3.14 * r ** 2
>>> print(f'The area of a circle with radius {r} is {s:.2f}')
The area of a circle with radius 2.5 is 19.62
```
