---
title: 闭包
tags: []
categories: ['javascript']
date: 2021-07-29 13:42:18
---

## 闭包的概念

一个函数和对其周围状态（lexical environment，词法环境）的引用组合在一起，就是闭包（closure）。闭包让我们可以在一个内层函数中访问到其外层函数的作用域。

例如：

```js
function makeFunc() {
    var name = "Mozilla";
    function displayName() {
        alert(name);
    }
    return displayName;
}

var myFunc = makeFunc();
myFunc();
```


## 闭包的作用

- 用闭包模拟私有方法

```js
var makeCounter = function() {
  var privateCounter = 0;
  function changeBy(val) {
    privateCounter += val;
  }
  return {
    increment: function() {
      changeBy(1);
    },
    decrement: function() {
      changeBy(-1);
    },
    value: function() {
      return privateCounter;
    }
  }
};

var Counter1 = makeCounter();
var Counter2 = makeCounter();
console.log(Counter1.value()); /* logs 0 */
Counter1.increment();
Counter1.increment();
console.log(Counter1.value()); /* logs 2 */
Counter1.decrement();
console.log(Counter1.value()); /* logs 1 */
console.log(Counter2.value()); /* logs 0 */
```


## 使用闭包的时应注意的问题

1. 在循环中创建闭包的常见错误--闭包只能取得它的包含函数（外层函数）的中变量的最后一个值

例如：

```js
function createFunctions() {
    var result = new Array();

    for (var i = 0; i < 10; i++){
        result[i] = function () {
            return i;
        }
    }

    return result;
}
```
这个函数返回一个函数数组，由于数组中的函数中都保存着变量i，在createFunctions()函数执行完毕时，变量i的值是10，所以每个函数都返回10。

**如果想让每个函数都返回其对应的索引值，可使用立即执行匿名函数(也是闭包)达到目的：**

```js
function createFunctions() {
    var result = new Array();

    for (var i = 0; i < 10; i++){
        result[i] = (function (n) {
            return function () {
                return n;
            }
        })(i);
    }

    return result;
}
```

**如果不想使用过多的闭包，也可以用ES2015引入的let关键词：**

```js
function createFunctions() {
    var result = new Array();

    for (let i = 0; i < 10; i++){
        result[i] = function () {
            return i;
        }
    }

    return result;
}
```

这个例子使用let而不是var，因此每个闭包都绑定了块作用域的变量，这样就不再需要额外的闭包。

2. 闭包中的this

this对象是指函数的执行环境对象，也就是函数的调用者。闭包函数中this同样指向它的调用者，但是我们常常不经意间就编写了一个闭包函数，这时候如果我们在闭包函数中使用了this，就容易和闭包的外层函数的this混淆。

例如：

```js
var name = 'the window';

function Foo(name) {
    this.name = name,                                  
    this.getName = function() {
        return function() {
            return this.name;
        }
    }
}
var obj = new Foo('my name');
alert(obj.getName()()); //'the window'(非严格模式下)
```

上述例子中的this指向window，但是我们很容易认为this指向obj，这很容易给我们的程序带来问题。为了避免这种问题。我们可以这样：

留在北京：两年后，在北京买个两居室，可乐在北京上幼儿园，房子装修。再过几年在天津买个房子，可乐可以在北京或者天津上小学，如果在天津上，需要有人在天津照顾，应该会选择在北京上直到初中转学去天津参加中考和上高中。

```js
var name = 'the window';

function Foo(name) {
    this.name = name,
    this.getName = function() {
        var self = this;
        return function() {
            return self.name;
        }
    }
}
var obj = new Foo('my name');
alert(obj.getName()()); //'my name'
```